import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Configuration constants
export const SYSTEM_PREFIX = 'pdl';
export const CSS_FILENAME = `${SYSTEM_PREFIX}.css`;

// Path constants
const SRC_DIR = '../src';
const DESIGN_TOKENS_PATH = `${SRC_DIR}/design-tokens`;
const GENERATED_STYLES_PATH = `${SRC_DIR}/styles/generated`;

// Used to create the chart CSS gradients in pdl.css
export const GRADIENT_PERCENT = 25;

// Generated file warning
export const FILE_WARNING = `/*
 * WARNING: DO NOT EDIT THIS FILE DIRECTLY.
 * This file is programmatically generated.
 * Generate new files by exporting JSON using the Design Tokens Manager
 * Figma plugin and run 'npm run build-pdl'
 */`;

// Font stack configurations
const FONT_STACK_MAP = {
  'CircularXXWeb':
    "'CircularXXWeb', ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
  'FK Grotesk':
    "'FK Grotesk', ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
  'Reddit Mono': "'Reddit Mono', ui-monospace, SFMono-Regular, Menlo, Monaco",
  'DM Mono': "'DM Mono', ui-monospace, SFMono-Regular, Menlo, Monaco",
};

// Shared utility functions
export function formatNumber(num) {
  return Number(num)
    .toFixed(2)
    .replace(/\.?0+$/, '');
}

export function pxToRem(px) {
  const numericValue = px.replace('px', '');
  return formatNumber(numericValue / 16);
}

export function camelToKebab(str) {
  return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
}

// Token file utilities
function getTokensDir() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  return path.join(__dirname, DESIGN_TOKENS_PATH);
}

export function getGeneratedStylesDir() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  return path.join(__dirname, GENERATED_STYLES_PATH);
}

export function loadTokenFile(filename) {
  const tokensDir = getTokensDir();
  const filePath = path.join(tokensDir, filename);
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

function loadManifest() {
  const tokensDir = getTokensDir();
  return JSON.parse(fs.readFileSync(path.join(tokensDir, 'manifest.json'), 'utf8'));
}

export function loadCollectionFiles(collectionName, modeName = null) {
  const manifest = loadManifest();
  const collection = manifest.collections[collectionName];
  if (!collection) return {};

  const modes = modeName ? { [modeName]: collection.modes[modeName] } : collection.modes;
  const result = {};

  for (const [, files] of Object.entries(modes)) {
    if (Array.isArray(files)) {
      for (const filename of files) {
        Object.assign(result, loadTokenFile(filename));
      }
    }
  }

  return result;
}

export function flattenTokens(obj, prefix = '', allTokens = null) {
  const result = {};

  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}-${key}` : key;

    if (value?.$value !== undefined) {
      let resolvedValue = value.$value;

      // Handle token references if allTokens is provided
      if (
        allTokens &&
        typeof resolvedValue === 'string' &&
        resolvedValue.startsWith('{') &&
        resolvedValue.endsWith('}')
      ) {
        resolvedValue = resolveTokenReference(resolvedValue, allTokens);
      }

      result[newKey] = { value: resolvedValue, type: value.$type };
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      Object.assign(result, flattenTokens(value, newKey, allTokens));
    }
  }

  return result;
}

function resolveTokenReference(value, allTokens) {
  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
    const path = value.slice(1, -1).split('.');
    let current = allTokens;

    for (const segment of path) {
      current = current?.[segment];
    }

    const resolvedValue = current?.$value || value;

    // Recursively resolve if the resolved value is also a token reference
    if (
      typeof resolvedValue === 'string' &&
      resolvedValue.startsWith('{') &&
      resolvedValue.endsWith('}')
    ) {
      return resolveTokenReference(resolvedValue, allTokens);
    }

    return resolvedValue;
  }
  return value;
}

// Font processing functions
export function processFontFamily(value) {
  return FONT_STACK_MAP[value] || value;
}

// CSS variable creation and value processing
export function createCssVariable(key, value, comment = '', prefix = '') {
  const varName = prefix ? `--${prefix}-${camelToKebab(key)}` : `--${camelToKebab(key)}`;
  const commentSuffix = comment ? ` /* ${comment} */` : '';
  return `  ${varName}: ${value};${commentSuffix}\n`;
}

export function processValue(value, type) {
  switch (type) {
    case 'dimension':
      const numericValue = value.replace('px', '');
      return {
        value: `${pxToRem(value)}rem`,
        comment: `${formatNumber(numericValue)}px`,
      };
    default:
      return { value };
  }
}
